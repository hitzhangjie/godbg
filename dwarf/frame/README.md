Call Frame Information
==============================================================================

调试器经常需要查看调用栈中不同栈帧中的状态信息，要想实现此功能，就必须具备**"给定
任意地址后计算出该地址所在的栈帧"**的能力。

实现此功能主要依赖于下面几点：

- 每个编译单元都由一个CIE描述，每个函数都由一个FDE描述，每个CIE后面跟着一系列的FDEs；

- 调用栈信息表，表中每行的编码格式如下：
  ```
  Loc | CFA | register rules | return address register | architecture
  ```
  当指定一个地址L1时，遍历FDEs，如果某个FDE的内存地址范围[FDE.initial,FDE.initial+FDE.size]
  可以覆盖L1时，说明指令地址L1对应的函数栈帧就找到了。
  
- 字节码指令，上面的表非常大，实际上每行机器指令都对应上表中的一行，如果全量存储每行指令执行时的
  状态信息，那数据量实在是太大了。
  这里的指令可以分为几类：行创建指令、CFA操作指令、寄存器操作指令、架构相关指令。
  为了压缩存储，可以由存储整张表转换为只编码存储相邻行的差异，即对有变更的CFA或者register编码。
  很自然地，可以通过一系列的字节码指令来代表对CFA或register的操作。这里的字节码指令，由对应的状态机
  执行之后，就可以构建出完整的上述的表结构。
  但是实际上，并不需要构建完整的表结构，只需要行创建指令创建出的行地址Loc>=L1即可，就可以停下了。
  
- 现在这个表结构有了，然后找到第一条Loc>=L1的行，找到其中的CFA以及register计算规则，用来计算出
  CFA以及register的值，用以还原上下文信息，以便进一步分析栈帧中的arguments、variables、...
  
以上，大致就是CFI表结构的构建过程，以及应用了。
